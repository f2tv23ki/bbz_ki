import serial
import time
import anvil.server

# Verbinde dich mit dem Anvil-Server
anvil.server.connect("server_4MBZIOXABKL5OA42VYKHGSON-V32HZTFRXD5FJXZA")

# Funktion zum Umrechnen von Dezimalwerten in Little-Endian Hex-Bytes
def decimal_to_hex_bytes_little_endian(decimal_value):
    """
    Konvertiert einen Dezimalwert (positiv oder negativ) in eine Liste von 4 Hexadezimalbytes 
    (32-Bit-Wert) im Little-Endian-Format.
    """
    if decimal_value < 0:
        decimal_value = (decimal_value + (1 << 32)) % (1 << 32)
    hex_value = f"{decimal_value:08X}"
    return [int(hex_value[i:i+2], 16) for i in range(6, -1, -2)]

# Beispiel-Positionswerte
position_motor1 = 340000
position_motor2 = 77500
position_motor3 = -950000  # Negativer Wert
position_motor4 = 120000
position_motor5 = 200000
position_motor6 = -3000  # Negativer Wert

# Umrechnen der Werte in Little-Endian Hex-Bytes
VAR_M1 = decimal_to_hex_bytes_little_endian(position_motor1)
VAR_M2 = decimal_to_hex_bytes_little_endian(position_motor2)
VAR_M3 = decimal_to_hex_bytes_little_endian(position_motor3)
VAR_M4 = decimal_to_hex_bytes_little_endian(position_motor4)
VAR_M5 = decimal_to_hex_bytes_little_endian(position_motor5)
VAR_M6 = decimal_to_hex_bytes_little_endian(position_motor6)

# Ausgabe der Variablen im Hex-Format
print("Motor 1 Hex Bytes:", ', '.join(f'0x{byte:02X}' for byte in VAR_M1))
print("Motor 2 Hex Bytes:", ', '.join(f'0x{byte:02X}' for byte in VAR_M2))
print("Motor 3 Hex Bytes:", ', '.join(f'0x{byte:02X}' for byte in VAR_M3))
print("Motor 4 Hex Bytes:", ', '.join(f'0x{byte:02X}' for byte in VAR_M4))
print("Motor 5 Hex Bytes:", ', '.join(f'0x{byte:02X}' for byte in VAR_M5))
print("Motor 6 Hex Bytes:", ', '.join(f'0x{byte:02X}' for byte in VAR_M6))

# G1-Liste: Befehle zur Steuerung der Motoren
G1 = [     
    [0x00, 0x13, 0x00, 0x40, 0x00, 0x0A, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x14, 0x00, 0x19, 0x00, 0x96, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0.01],
    [0x00, 0x23, 0x00, *VAR_M1, 0x00, 0x00, 10],
    
    [0x00, 0x13, 0x01, 0x64, 0x00, 0x0A, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x14, 0x01, 0x19, 0x00, 0xFA, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x15, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0.01],
    [0x00, 0x23, 0x01, *VAR_M2, 0x00, 0x00, 5],

    [0x00, 0x13, 0x02, 0xC8, 0x00, 0xFF, 0xA0, 0x00, 0x00, 0.01],
    [0x00, 0x14, 0x02, 0x19, 0x00, 0xFF, 0xCA, 0x00, 0x00, 0.01],
    [0x00, 0x15, 0x02, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0.01],
    [0x00, 0x23, 0x02, *VAR_M3, 0x00, 0x00, 5],

    [0x00, 0x13, 0x03, 0x64, 0x00, 0x0A, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x14, 0x03, 0x0F, 0x00, 0x96, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x15, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0.01],
    [0x00, 0x23, 0x03, *VAR_M4, 0x00, 0x00, 5],

    [0x00, 0x13, 0x04, 0xF8, 0x00, 0xFA, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x14, 0x04, 0x19, 0x00, 0xFF, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x15, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0.01],
    [0x00, 0x23, 0x04, *VAR_M5, 0x00, 0x00, 5],

    [0x00, 0x13, 0x05, 0xC2, 0x00, 0x0A, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x14, 0x05, 0x19, 0x00, 0xFA, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x15, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0.01],
    [0x00, 0x23, 0x05, *VAR_M6, 0x00, 0x00, 5],
]

# Erstellen einer neuen Liste test mit den Hex-Werten
test = []

print("\nG1-Liste:")
for line in G1:
    # Umwandlung der Werte in Hex und Dezimal für den letzten Wert (die Zeit)
    hex_line = [f"0x{value:02X}" if isinstance(value, int) else value for value in line[:-1]]
    hex_line.append(line[-1])  # Der letzte Wert bleibt im Dezimalformat
    test.append(hex_line)

# Ausgabe der finalen test-Liste
print("hallo")
print(test)





#G0 = Referenzfahrt
G0 = [
    
    # Hardware Reset
    [0x00, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 5],
    
    
    # Motor 6 - Greifer
    [0x00, 0x13, 0x05, 0xD2, 0x00, 0x0A, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x14, 0x05, 0x19, 0x00, 0xFA, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x15, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0.01],
    [0x00, 0x22, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 3],
    
    # Motor 1 - Arm Drehen referenzieren
    [0x00, 0x13, 0x00, 0xC8, 0x00, 0x0A, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x14, 0x00, 0x19, 0x00, 0xFA, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0.01],
    [0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0.01],
    
    # Motor 5 - Drehen Greifer
    [0x00, 0x13, 0x04, 0xF8, 0x00, 0xFA, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x14, 0x04, 0x19, 0x00, 0xFF, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x15, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0.01],
    [0x00, 0x22, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 25],
    [0x00, 0x23, 0x04, 0x30, 0x04, 0xFE, 0xFF, 0x00, 0x00, 5],
    
    # Motor 2 - Erster Arm
    [0x00, 0x13, 0x01, 0xB8, 0x00, 0x0A, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x14, 0x01, 0x19, 0x00, 0xFA, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x15, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0.01],
    [0x00, 0x22, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 20],
    [0x00, 0x23, 0x01, 0xBC, 0x2E, 0x01, 0x00, 0x00, 0x00, 5],
    
    # Motor 4 - 2. Arm Oberes Gelenk - Referenz
    [0x00, 0x13, 0x03, 0xD8, 0x00, 0x0A, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x14, 0x03, 0x19, 0x00, 0xEA, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x15, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0.01],
    [0x00, 0x22, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 25],
    
    # Motor 4 - 2. Arm Oberes Gelenk - Sicherheitsposi
    [0x00, 0x13, 0x03, 0x64, 0x00, 0x0A, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x14, 0x03, 0x19, 0x00, 0xD5, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x15, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0.01],
    [0x00, 0x23, 0x03, 0xC0, 0xD4, 0x01, 0x00, 0x00, 0x00, 5],
    
    
    # Motor 3 - 2. Arm Unten Gelenk - Referenz
    [0x00, 0x13, 0x02, 0xC8, 0x00, 0xFF, 0xA0, 0x00, 0x00, 0.01],
    [0x00, 0x14, 0x02, 0x19, 0x00, 0xFF, 0xCA, 0x00, 0x00, 0.01],
    [0x00, 0x15, 0x02, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0.01],
    [0x00, 0x22, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 20],
    
    # Motor 3 - 2. Arm Unten Gelenk - Sicherheitsposi
    [0x00, 0x13, 0x02, 0x64, 0x00, 0x0A, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x14, 0x02, 0x19, 0x00, 0xC8, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x15, 0x02, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0.01],
    [0x00, 0x23, 0x02, 0xF8, 0x24, 0x01, 0x00, 0x00, 0x00, 5],
    
    # Motor 1 - Arm Drehen
    [0x00, 0x13, 0x00, 0x64, 0x00, 0x0A, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x14, 0x00, 0x19, 0x00, 0xFA, 0x00, 0x00, 0x00, 0.01],
    [0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0.01],
    [0x00, 0x23, 0x00, 0x10, 0x98, 0x02, 0x00, 0x00, 0x00, 5],
    
   
    # Auf Grundlage der Referenzfahrt, Abfolge muss eingehalten werden
    
]


#dictionary für die Listen
commands = {
    "G0": G0,
    "G1": G1
}

@anvil.server.callable
def gesamter_text(text):
    print(f"Text von Anvil: (text)")
print("Warte auf Anvil")
anvil.server.wait_forever()


# Serielle Verbindung konfigurieren
ser = serial.Serial(
    port='/dev/ttyUSB0',
    baudrate=19200,
    bytesize=serial.EIGHTBITS,
    parity=serial.PARITY_NONE,
    stopbits=serial.STOPBITS_ONE,
    timeout=1
)

time.sleep(2)

def send_command(command):
    """Sendet einen einzelnen Befehl über die serielle Schnittstelle."""
    ser.write(bytearray(command[:-1]))  # Letztes Element ist die Wartezeit, daher ausschließen
    ser.flush()  # Wartet, bis alle Daten gesendet wurden

# Sende alle Befehle mit angegebener Pause
for command in commands:
    wait_time = command[-1]  # Die Wartezeit ist das letzte Element des Befehls
    print("Sending command:", command[:-1])
    send_command(command)
    print(f"Waiting for {wait_time} seconds")
    time.sleep(wait_time)  # Wartezeit ausführen

# Verbindung schließen
ser.close()

